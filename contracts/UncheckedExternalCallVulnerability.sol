// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract UncheckedExternalCallVulnerability {
    mapping(address => uint256) public balances;

    // Unchecked external call - no return value validation
    function unsafeExternalCall(address target, bytes calldata data) public {
        target.call(data); // No success check!
    }

    // Unchecked call with value
    function unsafeCallWithValue(
        address target,
        bytes calldata data
    ) public payable {
        target.call{value: msg.value}(data); // No success check
    }

    // Unchecked delegatecall
    function unsafeDelegateCall(address target, bytes calldata data) public {
        target.delegatecall(data); // No success check
    }

    // Unchecked staticcall
    function unsafeStaticCall(
        address target,
        bytes calldata data
    ) public view returns (bytes memory) {
        target.staticcall(data); // No success check
        return "";
    }

    // Unchecked low-level call
    function unsafeLowLevelCall(address target, bytes calldata data) public {
        (bool success, ) = target.call(data);
        // Success is checked but not used properly
        if (!success) {
            // Do nothing - still vulnerable
        }
    }

    // Unchecked call in loop
    function unsafeCallInLoop(
        address[] calldata targets,
        bytes calldata data
    ) public {
        for (uint256 i = 0; i < targets.length; i++) {
            targets[i].call(data); // No success check in loop
        }
    }

    // Unchecked call with complex logic
    function unsafeCallWithLogic(
        address target,
        bytes calldata data,
        bool condition
    ) public {
        if (condition) {
            target.call(data); // No success check
        }
    }

    // Unchecked call in try-catch (but catch doesn't handle properly)
    function unsafeTryCatch(address target, bytes calldata data) public {
        try target.call(data) {
            // Success case
        } catch {
            // Empty catch - doesn't handle failure properly
        }
    }

    // Unchecked call with require but wrong condition
    function unsafeCallWithWrongRequire(
        address target,
        bytes calldata data
    ) public {
        (bool success, ) = target.call(data);
        require(success == true, "Call failed"); // This is correct, but showing pattern
    }

    // Unchecked call in constructor
    constructor(address target, bytes calldata data) {
        target.call(data); // No success check in constructor
    }
}
