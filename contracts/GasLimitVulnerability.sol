// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GasLimitVulnerability {
    mapping(address => uint256) public balances;
    address[] public users;

    // Unbounded loop - can exceed gas limit
    function unboundedLoop() public {
        for (uint256 i = 0; i < users.length; i++) {
            balances[users[i]] += 1; // Can run out of gas
        }
    }

    // Gas limit vulnerability in array operations
    function addUser(address user) public {
        users.push(user); // Array can grow indefinitely
    }

    // Gas limit in mapping iteration
    function iterateMapping() public {
        // No way to iterate mapping safely
        // This is a conceptual example
    }

    // Gas limit in recursive function
    function recursiveFunction(uint256 depth) public {
        if (depth > 0) {
            recursiveFunction(depth - 1); // Can cause stack overflow
        }
    }

    // Gas limit in complex calculations
    function complexCalculation(
        uint256 iterations
    ) public pure returns (uint256) {
        uint256 result = 0;
        for (uint256 i = 0; i < iterations; i++) {
            result += i * i; // Can consume too much gas
        }
        return result;
    }

    // Gas limit in string operations
    function stringOperation(
        string memory input
    ) public pure returns (string memory) {
        bytes memory bytesInput = bytes(input);
        bytes memory result = new bytes(bytesInput.length * 2);

        for (uint256 i = 0; i < bytesInput.length; i++) {
            result[i * 2] = bytesInput[i];
            result[i * 2 + 1] = bytesInput[i];
        }

        return string(result);
    }

    // Gas limit in storage operations
    function storageOperation(uint256 count) public {
        for (uint256 i = 0; i < count; i++) {
            balances[address(uint160(i))] = i; // Many storage writes
        }
    }

    // Gas limit in event emissions
    function emitManyEvents(uint256 count) public {
        for (uint256 i = 0; i < count; i++) {
            emit UserEvent(address(uint160(i)), i);
        }
    }

    // Gas limit in external calls
    function multipleExternalCalls(address[] calldata targets) public {
        for (uint256 i = 0; i < targets.length; i++) {
            (bool success, ) = targets[i].call("");
            require(success, "Call failed");
        }
    }

    // Gas limit in memory allocation
    function memoryAllocation(uint256 size) public pure returns (bytes memory) {
        return new bytes(size); // Can allocate too much memory
    }

    event UserEvent(address user, uint256 value);
}
