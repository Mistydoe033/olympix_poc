// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FrontRunningVulnerability {
    mapping(address => uint256) public balances;
    uint256 public tokenPrice;
    uint256 public totalSupply;

    // Front-running vulnerable order book
    function placeOrder(uint256 amount, bool isBuy) public {
        if (isBuy) {
            require(
                balances[msg.sender] >= amount * tokenPrice,
                "Insufficient balance"
            );
            balances[msg.sender] -= amount * tokenPrice;
            totalSupply += amount;
        } else {
            require(totalSupply >= amount, "Insufficient supply");
            totalSupply -= amount;
            balances[msg.sender] += amount * tokenPrice;
        }
        // No slippage protection - vulnerable to front-running
    }

    // Front-running vulnerable token sale
    function buyTokens() public payable {
        uint256 tokensToReceive = msg.value / tokenPrice;
        totalSupply += tokensToReceive;
        balances[msg.sender] += tokensToReceive;
        // Price doesn't change - vulnerable to front-running
    }

    // Front-running vulnerable auction
    function placeBid() public payable {
        require(msg.value > tokenPrice, "Bid too low");
        tokenPrice = msg.value;
        // No time delay - vulnerable to front-running
    }

    // Front-running vulnerable oracle update
    function updatePrice(uint256 newPrice) public {
        tokenPrice = newPrice;
        // No validation - vulnerable to manipulation
    }

    // Front-running vulnerable lottery
    function enterLottery() public payable {
        require(msg.value == 1 ether, "Must send exactly 1 ETH");
        // Winner determined by transaction order - vulnerable
    }

    // Front-running vulnerable governance
    function proposeVote(bytes32 proposal) public {
        // Proposal accepted based on order - vulnerable
    }

    // Front-running vulnerable flash loan
    function flashLoan(uint256 amount) public {
        // No reentrancy protection - vulnerable
        balances[msg.sender] += amount;
        // Flash loan logic here
        balances[msg.sender] -= amount;
    }

    // Front-running vulnerable arbitrage
    function arbitrage(address tokenA, address tokenB) public {
        // No slippage protection - vulnerable
        uint256 priceA = getPrice(tokenA);
        uint256 priceB = getPrice(tokenB);
        if (priceA < priceB) {
            // Arbitrage logic
        }
    }

    // Front-running vulnerable liquidation
    function liquidate(address user) public {
        uint256 collateral = balances[user];
        uint256 debt = getDebt(user);
        if (collateral < debt) {
            // Liquidate without protection
        }
    }

    // Front-running vulnerable reward distribution
    function claimReward() public {
        uint256 reward = calculateReward(msg.sender);
        balances[msg.sender] += reward;
        // No protection against front-running
    }

    function getPrice(address token) internal view returns (uint256) {
        // Mock price function
        return 100;
    }

    function getDebt(address user) internal view returns (uint256) {
        // Mock debt function
        return 50;
    }

    function calculateReward(address user) internal view returns (uint256) {
        // Mock reward calculation
        return 10;
    }
}
