// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FlashLoanVulnerability {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public debts;

    // Flash loan without proper validation
    function flashLoan(uint256 amount) public {
        require(amount > 0, "Amount must be greater than 0");

        // Lend the amount
        balances[msg.sender] += amount;

        // Call the borrower's callback function
        // VULNERABLE: No validation of callback
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature("flashLoanCallback(uint256)", amount)
        );
        require(success, "Callback failed");

        // Check if amount is repaid
        require(balances[msg.sender] >= amount, "Flash loan not repaid");
        balances[msg.sender] -= amount;
    }

    // Flash loan with weak validation
    function flashLoanWithWeakValidation(uint256 amount) public {
        balances[msg.sender] += amount;

        // Weak validation - only checks if callback exists
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature("callback()")
        );
        if (success) {
            // Assume repayment happened
        }

        // No proper repayment check
        balances[msg.sender] -= amount;
    }

    // Flash loan with reentrancy vulnerability
    function flashLoanWithReentrancy(uint256 amount) public {
        balances[msg.sender] += amount;

        // State change after external call - VULNERABLE!
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature("callback()")
        );
        require(success, "Callback failed");

        // State change too late
        require(balances[msg.sender] >= amount, "Not repaid");
        balances[msg.sender] -= amount;
    }

    // Flash loan with oracle manipulation
    function flashLoanWithOracleManipulation(uint256 amount) public {
        balances[msg.sender] += amount;

        // Callback can manipulate oracle
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature("manipulateOracle()")
        );
        require(success, "Callback failed");

        // Use manipulated oracle price
        uint256 price = getOraclePrice();
        require(balances[msg.sender] >= amount * price, "Not repaid");
        balances[msg.sender] -= amount;
    }

    // Flash loan with governance attack
    function flashLoanWithGovernance(uint256 amount) public {
        balances[msg.sender] += amount;

        // Callback can vote in governance
        (bool success, ) = msg.sender.call(abi.encodeWithSignature("vote()"));
        require(success, "Callback failed");

        // Check repayment
        require(balances[msg.sender] >= amount, "Not repaid");
        balances[msg.sender] -= amount;
    }

    // Flash loan with liquidation attack
    function flashLoanWithLiquidation(uint256 amount) public {
        balances[msg.sender] += amount;

        // Callback can liquidate positions
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature("liquidate()")
        );
        require(success, "Callback failed");

        // Check repayment
        require(balances[msg.sender] >= amount, "Not repaid");
        balances[msg.sender] -= amount;
    }

    // Flash loan with arbitrage
    function flashLoanWithArbitrage(uint256 amount) public {
        balances[msg.sender] += amount;

        // Callback can perform arbitrage
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature("arbitrage()")
        );
        require(success, "Callback failed");

        // Check repayment
        require(balances[msg.sender] >= amount, "Not repaid");
        balances[msg.sender] -= amount;
    }

    // Flash loan with price manipulation
    function flashLoanWithPriceManipulation(uint256 amount) public {
        balances[msg.sender] += amount;

        // Callback can manipulate prices
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature("manipulatePrice()")
        );
        require(success, "Callback failed");

        // Use manipulated price
        uint256 price = getPrice();
        require(balances[msg.sender] >= amount * price, "Not repaid");
        balances[msg.sender] -= amount;
    }

    // Flash loan with no fee
    function flashLoanNoFee(uint256 amount) public {
        balances[msg.sender] += amount;

        // No fee charged - vulnerable to abuse
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature("callback()")
        );
        require(success, "Callback failed");

        require(balances[msg.sender] >= amount, "Not repaid");
        balances[msg.sender] -= amount;
    }

    function getOraclePrice() internal view returns (uint256) {
        // Mock oracle price
        return 100;
    }

    function getPrice() internal view returns (uint256) {
        // Mock price function
        return 100;
    }
}
