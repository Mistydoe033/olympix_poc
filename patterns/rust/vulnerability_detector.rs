use std::collections::HashMap;
use regex::Regex;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub vulnerability_type: VulnerabilityType,
    pub line_number: usize,
    pub description: String,
    pub severity: Severity,
    pub code_snippet: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VulnerabilityType {
    Overflow,
    Reentrancy,
    AccessControl,
    UncheckedExternalCall,
    TimestampDependence,
    GasLimit,
    UncheckedReturn,
    FrontRunning,
    FlashLoan,
    OracleManipulation,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

pub struct VulnerabilityDetector {
    patterns: HashMap<VulnerabilityType, Vec<Regex>>,
}

impl VulnerabilityDetector {
    pub fn new() -> Self {
        let mut patterns = HashMap::new();
        
        // Overflow patterns
        patterns.insert(VulnerabilityType::Overflow, vec![
            Regex::new(r"(\w+)\s*\+=\s*\w+").unwrap(),
            Regex::new(r"(\w+)\s*-\s*\w+").unwrap(),
            Regex::new(r"(\w+)\s*\*\s*\w+").unwrap(),
            Regex::new(r"\w+\[\w+\]").unwrap(),
            Regex::new(r"for\s*\(\s*uint256\s+\w+\s*=\s*0;\s*\w+\s*<\s*\w+;\s*\w+\+\+\s*\)").unwrap(),
        ]);
        
        // Reentrancy patterns
        patterns.insert(VulnerabilityType::Reentrancy, vec![
            Regex::new(r"\(bool\s+success,\s*\)\s*=\s*msg\.sender\.call").unwrap(),
            Regex::new(r"msg\.sender\.call\{value:\s*\w+\}").unwrap(),
            Regex::new(r"receive\(\)\s+external\s+payable").unwrap(),
            Regex::new(r"fallback\(\)\s+external\s+payable").unwrap(),
        ]);
        
        // Access Control patterns
        patterns.insert(VulnerabilityType::AccessControl, vec![
            Regex::new(r"function\s+\w+\([^)]*\)\s+public\s*\{").unwrap(),
            Regex::new(r"tx\.origin\s*==\s*\w+").unwrap(),
            Regex::new(r"require\(msg\.sender\s*!=\s*address\(0\)").unwrap(),
        ]);
        
        // Unchecked External Call patterns
        patterns.insert(VulnerabilityType::UncheckedExternalCall, vec![
            Regex::new(r"target\.call\(data\)").unwrap(),
            Regex::new(r"\w+\.call\(\w+\)").unwrap(),
            Regex::new(r"target\.delegatecall\(data\)").unwrap(),
        ]);
        
        // Timestamp Dependence patterns
        patterns.insert(VulnerabilityType::TimestampDependence, vec![
            Regex::new(r"block\.timestamp").unwrap(),
            Regex::new(r"keccak256\(abi\.encodePacked\(block\.timestamp").unwrap(),
            Regex::new(r"block\.timestamp\s*%\s*\w+").unwrap(),
        ]);
        
        // Gas Limit patterns
        patterns.insert(VulnerabilityType::GasLimit, vec![
            Regex::new(r"for\s*\([^)]*\)\s*\{[^}]*\w+\.length[^}]*\}").unwrap(),
            Regex::new(r"\w+\.push\(").unwrap(),
            Regex::new(r"while\s*\([^)]*\)\s*\{[^}]*\}").unwrap(),
        ]);
        
        // Unchecked Return patterns
        patterns.insert(VulnerabilityType::UncheckedReturn, vec![
            Regex::new(r"target\.call\(data\)").unwrap(),
            Regex::new(r"\w+\.transfer\(\w+\)").unwrap(),
            Regex::new(r"\w+\.send\(\w+\)").unwrap(),
        ]);
        
        // Front Running patterns
        patterns.insert(VulnerabilityType::FrontRunning, vec![
            Regex::new(r"\w+\s*=\s*msg\.value\s*/\s*\w+").unwrap(),
            Regex::new(r"\w+\s*=\s*\w+\s*/\s*\w+").unwrap(),
            Regex::new(r"require\(msg\.value\s*==\s*\w+\)").unwrap(),
        ]);
        
        // Flash Loan patterns
        patterns.insert(VulnerabilityType::FlashLoan, vec![
            Regex::new(r"\w+\[msg\.sender\]\s*\+\s*=\s*\w+").unwrap(),
            Regex::new(r"flashLoanCallback\(").unwrap(),
            Regex::new(r"callback\(\)").unwrap(),
        ]);
        
        // Oracle Manipulation patterns
        patterns.insert(VulnerabilityType::OracleManipulation, vec![
            Regex::new(r"getPriceFromSingleOracle").unwrap(),
            Regex::new(r"oraclePrice").unwrap(),
            Regex::new(r"\w+\s*=\s*\w+\s*/\s*\w+").unwrap(),
        ]);
        
        VulnerabilityDetector { patterns }
    }
    
    pub fn scan_contract(&self, contract_content: &str) -> Vec<Vulnerability> {
        let mut vulnerabilities = Vec::new();
        let lines: Vec<&str> = contract_content.lines().collect();
        
        for (line_number, line) in lines.iter().enumerate() {
            for (vuln_type, patterns) in &self.patterns {
                for pattern in patterns {
                    if pattern.is_match(line) {
                        let severity = self.get_severity(vuln_type);
                        let description = self.get_description(vuln_type);
                        
                        vulnerabilities.push(Vulnerability {
                            vulnerability_type: vuln_type.clone(),
                            line_number: line_number + 1,
                            description,
                            severity,
                            code_snippet: line.trim().to_string(),
                        });
                    }
                }
            }
        }
        
        vulnerabilities
    }
    
    fn get_severity(&self, vuln_type: &VulnerabilityType) -> Severity {
        match vuln_type {
            VulnerabilityType::Reentrancy => Severity::Critical,
            VulnerabilityType::Overflow => Severity::High,
            VulnerabilityType::AccessControl => Severity::High,
            VulnerabilityType::UncheckedExternalCall => Severity::High,
            VulnerabilityType::FlashLoan => Severity::High,
            VulnerabilityType::OracleManipulation => Severity::High,
            VulnerabilityType::FrontRunning => Severity::Medium,
            VulnerabilityType::TimestampDependence => Severity::Medium,
            VulnerabilityType::GasLimit => Severity::Medium,
            VulnerabilityType::UncheckedReturn => Severity::Medium,
        }
    }
    
    fn get_description(&self, vuln_type: &VulnerabilityType) -> String {
        match vuln_type {
            VulnerabilityType::Overflow => "Integer overflow/underflow vulnerability detected".to_string(),
            VulnerabilityType::Reentrancy => "Reentrancy vulnerability detected - external calls before state changes".to_string(),
            VulnerabilityType::AccessControl => "Missing or weak access control detected".to_string(),
            VulnerabilityType::UncheckedExternalCall => "Unchecked external call detected".to_string(),
            VulnerabilityType::TimestampDependence => "Timestamp dependence vulnerability detected".to_string(),
            VulnerabilityType::GasLimit => "Potential gas limit vulnerability detected".to_string(),
            VulnerabilityType::UncheckedReturn => "Unchecked return value detected".to_string(),
            VulnerabilityType::FrontRunning => "Front-running vulnerability detected".to_string(),
            VulnerabilityType::FlashLoan => "Flash loan vulnerability detected".to_string(),
            VulnerabilityType::OracleManipulation => "Oracle manipulation vulnerability detected".to_string(),
        }
    }
    
    pub fn scan_multiple_contracts(&self, contracts: &HashMap<String, String>) -> HashMap<String, Vec<Vulnerability>> {
        let mut results = HashMap::new();
        
        for (contract_name, contract_content) in contracts {
            let vulnerabilities = self.scan_contract(contract_content);
            results.insert(contract_name.clone(), vulnerabilities);
        }
        
        results
    }
    
    pub fn get_vulnerability_summary(&self, vulnerabilities: &[Vulnerability]) -> HashMap<VulnerabilityType, usize> {
        let mut summary = HashMap::new();
        
        for vuln in vulnerabilities {
            *summary.entry(vuln.vulnerability_type.clone()).or_insert(0) += 1;
        }
        
        summary
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_overflow_detection() {
        let detector = VulnerabilityDetector::new();
        let contract = "function deposit() public payable { balances[msg.sender] += msg.value; }";
        let vulnerabilities = detector.scan_contract(contract);
        
        assert!(!vulnerabilities.is_empty());
        assert_eq!(vulnerabilities[0].vulnerability_type, VulnerabilityType::Overflow);
    }
    
    #[test]
    fn test_reentrancy_detection() {
        let detector = VulnerabilityDetector::new();
        let contract = "function withdraw() public { (bool success, ) = msg.sender.call{value: amount}(\"\"); }";
        let vulnerabilities = detector.scan_contract(contract);
        
        assert!(!vulnerabilities.is_empty());
        assert_eq!(vulnerabilities[0].vulnerability_type, VulnerabilityType::Reentrancy);
    }
} 